--- snmpget.c   2024-09-13 18:19:48
+++ snmpget.cpp 2024-09-13 18:19:48
@@ -1,3 +1,4 @@
+/* straight copy from https://github.com/net-snmp/net-snmp/tree/master/apps */
 /*
  * snmpget.c - send snmp GET requests to a network entity.
  *
@@ -68,13 +69,19 @@
 
 #define NETSNMP_DS_APP_DONT_FIX_PDUS 0
 
-static void
-optProc(int argc, char *const *argv, int opt)
+#include <stdexcept>
+#include "snmpget.h"
+#include "helpers.h"
+
+void snmpget_optProc(int argc, char *const *argv, int opt)
 {
-    switch (opt) {
+   switch (opt)
+   {
     case 'C':
-        while (*optarg) {
-            switch (*optarg++) {
+      while (*optarg)
+      {
+         switch (*optarg++)
+         {
             case 'f':
                 netsnmp_ds_toggle_boolean(NETSNMP_DS_APPLICATION_ID, 
 					  NETSNMP_DS_APP_DONT_FIX_PDUS);
@@ -89,8 +96,7 @@
     }
 }
 
-void
-usage(void)
+void snmpget_usage(void)
 {
     fprintf(stderr, "USAGE: snmpget ");
     snmp_parse_args_usage(stderr);
@@ -102,9 +108,9 @@
             "\t\t\t  f:  do not fix errors and retry the request\n");
 }
 
-int
-main(int argc, char *argv[])
+std::vector<std::string> snmpget(int argc, char *argv[])
 {
+   std::vector<std::string> return_vector;
     netsnmp_session session, *ss;
     netsnmp_pdu    *pdu;
     netsnmp_pdu    *response;
@@ -124,29 +130,34 @@
     /*
      * get the common command line arguments 
      */
-    switch (arg = snmp_parse_args(argc, argv, &session, "C:", optProc)) {
+   switch (arg = snmp_parse_args(argc, argv, &session, "C:", snmpget_optProc))
+   {
     case NETSNMP_PARSE_ARGS_ERROR:
-        goto out;
+      throw std::runtime_error("NETSNMP_PARSE_ARGS_ERROR");
+
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exitval = 0;
-        goto out;
+      throw std::runtime_error("NETSNMP_PARSE_ARGS_SUCCESS_EXIT");
+
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
-        usage();
-        goto out;
+      snmpget_usage();
+      return return_vector;
+
     default:
         break;
     }
 
-    if (arg >= argc) {
+   if (arg >= argc)
+   {
         fprintf(stderr, "Missing object name\n");
-        usage();
-        goto out;
+      snmpget_usage();
+      return return_vector;
     }
-    if ((argc - arg) > SNMP_MAX_CMDLINE_OIDS) {
+   if ((argc - arg) > SNMP_MAX_CMDLINE_OIDS)
+   {
         fprintf(stderr, "Too many object identifiers specified. ");
         fprintf(stderr, "Only %d allowed in one request.\n", SNMP_MAX_CMDLINE_OIDS);
-        usage();
-        goto out;
+      snmpget_usage();
+      return return_vector;
     }
 
     /*
@@ -159,28 +170,32 @@
      * Open an SNMP session.
      */
     ss = snmp_open(&session);
-    if (ss == NULL) {
+   if (ss == NULL)
+   {
         /*
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmpget", &session);
-        goto out;
+      return return_vector;
     }
 
-
     /*
      * Create PDU for GET request and add object names to request.
      */
     pdu = snmp_pdu_create(SNMP_MSG_GET);
-    for (count = 0; count < current_name; count++) {
+   for (count = 0; count < current_name; count++)
+   {
         name_length = MAX_OID_LEN;
-        if (!snmp_parse_oid(names[count], name, &name_length)) {
+      if (!snmp_parse_oid(names[count], name, &name_length))
+      {
             snmp_perror(names[count]);
             failures++;
-        } else
+      }
+      else
             snmp_add_null_var(pdu, name, name_length);
     }
-    if (failures) {
+   if (failures)
+   {
         snmp_free_pdu(pdu);
         goto close_session;
     }
@@ -195,23 +210,31 @@
      */
   retry:
     status = snmp_synch_response(ss, pdu, &response);
-    if (status == STAT_SUCCESS) {
-        if (response->errstat == SNMP_ERR_NOERROR) {
+   if (status == STAT_SUCCESS)
+   {
+      if (response->errstat == SNMP_ERR_NOERROR)
+      {
             for (vars = response->variables; vars;
                  vars = vars->next_variable)
-                print_variable(vars->name, vars->name_length, vars);
-
-        } else {
+         {
+            auto str_value = print_variable_to_string(vars->name, vars->name_length, vars);
+            return_vector.push_back(str_value);
+         }
+      }
+      else
+      {
             fprintf(stderr, "Error in packet\nReason: %s\n",
                     snmp_errstring(response->errstat));
 
-            if (response->errindex != 0) {
+         if (response->errindex != 0)
+         {
                 fprintf(stderr, "Failed object: ");
                 for (count = 1, vars = response->variables;
                      vars && count != response->errindex;
                      vars = vars->next_variable, count++)
                     /*EMPTY*/;
-                if (vars) {
+            if (vars)
+            {
                     fprint_objid(stderr, vars->name, vars->name_length);
 		}
                 fprintf(stderr, "\n");
@@ -222,36 +245,40 @@
              * retry if the errored variable was successfully removed 
              */
             if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
-					NETSNMP_DS_APP_DONT_FIX_PDUS)) {
+                                     NETSNMP_DS_APP_DONT_FIX_PDUS))
+         {
                 pdu = snmp_fix_pdu(response, SNMP_MSG_GET);
                 snmp_free_pdu(response);
                 response = NULL;
-                if (pdu != NULL) {
+            if (pdu != NULL)
+            {
                     goto retry;
 		}
             }
         }                       /* endif -- SNMP_ERR_NOERROR */
-
-    } else if (status == STAT_TIMEOUT) {
+   }
+   else if (status == STAT_TIMEOUT)
+   {
         fprintf(stderr, "Timeout: No Response from %s.\n",
                 session.peername);
         exitval = 1;
-
-    } else {                    /* status == STAT_ERROR */
+   }
+   else
+   { /* status == STAT_ERROR */
         snmp_sess_perror("snmpget", ss);
         exitval = 1;
 
     }                           /* endif -- STAT_SUCCESS */
 
-
     if (response)
         snmp_free_pdu(response);
 
 close_session:
     snmp_close(ss);
+   return return_vector;
 
 out:
     netsnmp_cleanup_session(&session);
     SOCK_CLEANUP;
-    return exitval;
+   return return_vector;
 }                               /* end main() */
