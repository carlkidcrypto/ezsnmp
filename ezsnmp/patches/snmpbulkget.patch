--- net-snmp-master/apps/snmpbulkget.c 2024-09-06 10:48:16
+++ snmpbulkget.cpp                    2024-10-01 09:25:39
@@ -1,3 +1,4 @@
+/* straight copy from https://github.com/net-snmp/net-snmp/tree/master/apps */
 /*
  * snmpbulkget.c - send SNMPv2 Bulk requests to a network entity.
  *
@@ -65,17 +66,21 @@
 
 #include <net-snmp/net-snmp-includes.h>
 
-oid             objid_mib[] = { 1, 3, 6, 1, 2, 1 };
+oid snmpbulkget_objid_mib[] = {1, 3, 6, 1, 2, 1};
 int             max_repetitions = 10;
 int             non_repeaters = 0;
-struct nameStruct {
+struct nameStruct
+{
     oid             name[MAX_OID_LEN];
     size_t          name_len;
 }              *name, *namep;
 int             names;
 
-void
-usage(void)
+#include <stdexcept>
+#include "snmpbulkget.h"
+#include "helpers.h"
+
+void snmpbulkget_usage(void)
 {
     fprintf(stderr, "USAGE: snmpbulkget ");
     snmp_parse_args_usage(stderr);
@@ -87,33 +92,41 @@
     fprintf(stderr, "\t\t\t  r<NUM>:  set max-repeaters to <NUM>\n");
 }
 
-static
-    void
-optProc(int argc, char *const *argv, int opt)
+void snmpbulkget_optProc(int argc, char *const *argv, int opt)
 {
     char           *endptr = NULL;
 
-    switch (opt) {
+   switch (opt)
+   {
     case 'C':
-        while (*optarg) {
-            switch (*optarg++) {
+      while (*optarg)
+      {
+         switch (*optarg++)
+         {
             case 'n':
             case 'r':
-                if (*(optarg - 1) == 'r') {
+            if (*(optarg - 1) == 'r')
+            {
                     max_repetitions = strtol(optarg, &endptr, 0);
-                } else {
+            }
+            else
+            {
                     non_repeaters = strtol(optarg, &endptr, 0);
                 }
 
-                if (endptr == optarg) {
+            if (endptr == optarg)
+            {
                     /*
                      * No number given -- error.  
                      */
-                    usage();
+               snmpbulkget_usage();
                     exit(1);
-                } else {
+            }
+            else
+            {
                     optarg = endptr;
-                    if (isspace((unsigned char)(*optarg))) {
+               if (isspace((unsigned char)(*optarg)))
+               {
                         return;
                     }
                 }
@@ -128,9 +141,12 @@
     }
 }
 
-int
-main(int argc, char *argv[])
+std::vector<std::string> snmpbulkget(const std::vector<std::string> &args)
 {
+   int argc;
+   std::unique_ptr<char*[]> argv = create_argv(args, argc);
+
+   std::vector<std::string> return_vector;
     netsnmp_session session, *ss;
     netsnmp_pdu    *pdu;
     netsnmp_pdu    *response;
@@ -145,32 +161,38 @@
     /*
      * get the common command line arguments 
      */
-    switch (arg = snmp_parse_args(argc, argv, &session, "C:", optProc)) {
+   switch (arg = snmp_parse_args(argc, argv.get(), &session, "C:", snmpbulkget_optProc))
+   {
     case NETSNMP_PARSE_ARGS_ERROR:
-        goto out;
+      throw std::runtime_error("NETSNMP_PARSE_ARGS_ERROR");
+
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exitval = 0;
-        goto out;
+      throw std::runtime_error("NETSNMP_PARSE_ARGS_SUCCESS_EXIT");
+
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
-        usage();
-        goto out;
+      snmpbulkget_usage();
+      return return_vector;
+
     default:
         break;
     }
 
     names = argc - arg;
-    if (names < non_repeaters) {
+   if (names < non_repeaters)
+   {
         fprintf(stderr, "snmpbulkget: need more objects than <nonrep>\n");
-        goto out;
+      return return_vector;
     }
 
-    namep = name = calloc(names, sizeof(*name));
-    while (arg < argc) {
+   namep = name = (struct nameStruct *)calloc(names, sizeof(*name));
+   while (arg < argc)
+   {
         namep->name_len = MAX_OID_LEN;
         if (snmp_parse_oid(argv[arg], namep->name, &namep->name_len) ==
-            NULL) {
+          NULL)
+      {
             snmp_perror(argv[arg]);
-            goto out;
+         return return_vector;
         }
         arg++;
         namep++;
@@ -180,12 +202,13 @@
      * open an SNMP session 
      */
     ss = snmp_open(&session);
-    if (ss == NULL) {
+   if (ss == NULL)
+   {
         /*
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmpbulkget", &session);
-        goto out;
+      return return_vector;
     }
 
     exitval = 0;
@@ -203,24 +226,35 @@
      * do the request 
      */
     status = snmp_synch_response(ss, pdu, &response);
-    if (status == STAT_SUCCESS) {
-        if (response->errstat == SNMP_ERR_NOERROR) {
+   if (status == STAT_SUCCESS)
+   {
+      if (response->errstat == SNMP_ERR_NOERROR)
+      {
             /*
              * check resulting variables 
              */
             for (vars = response->variables; vars;
                  vars = vars->next_variable)
-                print_variable(vars->name, vars->name_length, vars);
-        } else {
+         {
+            auto str_value = print_variable_to_string(vars->name, vars->name_length, vars);
+            return_vector.push_back(str_value);
+         }
+      }
+      else
+      {
             /*
              * error in response, print it 
              */
-            if (response->errstat == SNMP_ERR_NOSUCHNAME) {
+         if (response->errstat == SNMP_ERR_NOSUCHNAME)
+         {
                 printf("End of MIB.\n");
-            } else {
+         }
+         else
+         {
                 fprintf(stderr, "Error in packet.\nReason: %s\n",
                         snmp_errstring(response->errstat));
-                if (response->errindex != 0) {
+            if (response->errindex != 0)
+            {
                     fprintf(stderr, "Failed object: ");
                     for (count = 1, vars = response->variables;
                          vars && (count != response->errindex);
@@ -234,11 +268,15 @@
                 exitval = 2;
             }
         }
-    } else if (status == STAT_TIMEOUT) {
+   }
+   else if (status == STAT_TIMEOUT)
+   {
         fprintf(stderr, "Timeout: No Response from %s\n",
                 session.peername);
         exitval = 1;
-    } else {                    /* status == STAT_ERROR */
+   }
+   else
+   { /* status == STAT_ERROR */
         snmp_sess_perror("snmpbulkget", ss);
         exitval = 1;
     }
@@ -251,5 +289,5 @@
 out:
     netsnmp_cleanup_session(&session);
     SOCK_CLEANUP;
-    return exitval;
+   return return_vector;
 }
