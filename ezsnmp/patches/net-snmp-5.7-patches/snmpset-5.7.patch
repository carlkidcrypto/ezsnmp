--- a/net-snmp-5.7/apps/snmpset.c
+++ b/net-snmp-5.7/apps/snmpset.cpp
@@ -1,3 +1,4 @@
+/* straight copy from https://github.com/net-snmp/net-snmp/tree/master/apps */
 /*
  * snmpset.c - send snmp SET requests to a network entity.
  *
@@ -25,73 +26,70 @@
 ******************************************************************/
 #include <net-snmp/net-snmp-config.h>
 
-#if HAVE_STDLIB_H
+#ifdef HAVE_STDLIB_H
 #include <stdlib.h>
 #endif
-#if HAVE_UNISTD_H
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_STRING_H
+#ifdef HAVE_STRING_H
 #include <string.h>
 #else
 #include <strings.h>
 #endif
 #include <sys/types.h>
-#if HAVE_NETINET_IN_H
+#ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
-#include <stdio.h>
 #include <ctype.h>
-#if TIME_WITH_SYS_TIME
+#include <stdio.h>
+#ifdef TIME_WITH_SYS_TIME
 # include <sys/time.h>
 # include <time.h>
 #else
-# if HAVE_SYS_TIME_H
+#ifdef HAVE_SYS_TIME_H
 #  include <sys/time.h>
 # else
 #  include <time.h>
 # endif
 #endif
-#if HAVE_SYS_SELECT_H
+#ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
 #endif
-#if HAVE_NETDB_H
+#ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
-#if HAVE_ARPA_INET_H
+#ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
 
 #include <net-snmp/net-snmp-includes.h>
 
-void
-usage(void)
-{
+#include <mutex>
+
+#include "exceptionsbase.h"
+#include "helpers.h"
+#include "snmpwalk.h"
+#include "thread_safety.h"
+
+void snmpset_usage(void) {
     fprintf(stderr, "USAGE: snmpset ");
     snmp_parse_args_usage(stderr);
     fprintf(stderr, " OID TYPE VALUE [OID TYPE VALUE]...\n\n");
     snmp_parse_args_descriptions(stderr);
-    fprintf(stderr,
-            "  -C APPOPTS\t\tSet various application specific behaviours:\n");
+   fprintf(stderr, "  -C APPOPTS\t\tSet various application specific behaviours:\n");
     fprintf(stderr, "\t\t\t  q:  don't print results on success\n");
     fprintf(stderr, "\n  TYPE: one of i, u, t, a, o, s, x, d, b\n");
-    fprintf(stderr,
-            "\ti: INTEGER, u: unsigned INTEGER, t: TIMETICKS, a: IPADDRESS\n");
-    fprintf(stderr,
-            "\to: OBJID, s: STRING, x: HEX STRING, d: DECIMAL STRING, b: BITS\n");
+   fprintf(stderr, "\ti: INTEGER, u: unsigned INTEGER, t: TIMETICKS, a: IPADDRESS\n");
+   fprintf(stderr, "\to: OBJID, s: STRING, x: HEX STRING, d: DECIMAL STRING, b: BITS\n");
 #ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
-    fprintf(stderr,
-            "\tU: unsigned int64, I: signed int64, F: float, D: double\n");
+   fprintf(stderr, "\tU: unsigned int64, I: signed int64, F: float, D: double\n");
 #endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */
-
 }
 
 static int quiet = 0;
 
-static
-    void
-optProc(int argc, char *const *argv, int opt)
-{
+void snmpset_optProc(int argc, char *const *argv, int opt) {
     switch (opt) {
     case 'C':
         while (*optarg) {
@@ -101,17 +99,23 @@
                 break;
 
             default:
-                fprintf(stderr, "Unknown flag passed to -C: %c\n",
-                        optarg[-1]);
-                exit(1);
+                  std::string err_msg =
+                      "Unknown flag passed to -C: " + std::string(1, optarg[-1]) + "\n";
+                  throw ParseErrorBase(err_msg);
             }
         }
     }
 }
 
-int
-main(int argc, char *argv[])
-{
+std::vector<Result> snmpset(std::vector<std::string> const &args,
+                            std::string const &init_app_name) {
+   // Reference-counted initialization: only first thread calls init_snmp
+   netsnmp_thread_init(init_app_name);
+
+   int argc;
+   std::unique_ptr<char *[], Deleter> argv = create_argv(args, argc);
+   std::vector<std::string> return_vector;
+
     netsnmp_session session, *ss;
     netsnmp_pdu    *pdu, *response = NULL;
     netsnmp_variable_list *vars;
@@ -127,44 +131,48 @@
     size_t          name_length;
     int             status;
     int             failures = 0;
-    int             exitval = 0;
+   /* Reset application-local quiet flag so subsequent calls behave normally. */
+   quiet = 0;
+
+   SOCK_STARTUP;
 
     putenv(strdup("POSIXLY_CORRECT=1"));
 
     /*
      * get the common command line arguments 
      */
-    switch (arg = snmp_parse_args(argc, argv, &session, "C:", optProc)) {
+   switch (arg = snmp_parse_args(argc, argv.get(), &session, "C:", snmpset_optProc)) {
     case NETSNMP_PARSE_ARGS_ERROR:
-        exit(1);
+         throw ParseErrorBase("NETSNMP_PARSE_ARGS_ERROR");
+
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exit(0);
+         throw ParseErrorBase("NETSNMP_PARSE_ARGS_SUCCESS_EXIT");
+
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
-        usage();
-        exit(1);
+         throw ParseErrorBase("NETSNMP_PARSE_ARGS_ERROR_USAGE");
+
     default:
         break;
     }
 
     if (arg >= argc) {
         fprintf(stderr, "Missing object name\n");
-        usage();
-        exit(1);
+      snmpset_usage();
+      goto out;
     }
     if ((argc - arg) > 3*SNMP_MAX_CMDLINE_OIDS) {
         fprintf(stderr, "Too many assignments specified. ");
         fprintf(stderr, "Only %d allowed in one request.\n", SNMP_MAX_CMDLINE_OIDS);
-        usage();
-        exit(1);
+      snmpset_usage();
+      goto out;
     }
 
     /*
      * get object names, types, and values 
      */
     for (; arg < argc; arg++) {
-        DEBUGMSGTL(("snmp_parse_args", "handling (#%d): %s %s %s\n",
-                    arg,argv[arg], arg+1 < argc ? argv[arg+1] : NULL,
-                    arg+2 < argc ? argv[arg+2] : NULL));
+      DEBUGMSGTL(("snmp_parse_args", "handling (#%d): %s %s %s\n", arg, argv[arg],
+                  arg + 1 < argc ? argv[arg + 1] : "", arg + 2 < argc ? argv[arg + 2] : ""));
         names[current_name++] = argv[arg++];
         if (arg < argc) {
             switch (*argv[arg]) {
@@ -179,6 +187,7 @@
             case 'x':
             case 'd':
             case 'b':
+            case 'n': /* undocumented */
 #ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
             case 'I':
             case 'U':
@@ -188,24 +197,21 @@
                 types[current_type++] = *argv[arg++];
                 break;
             default:
-                fprintf(stderr, "%s: Bad object type: %c\n", argv[arg - 1],
-                        *argv[arg]);
-                exit(1);
+               fprintf(stderr, "%s: Bad object type: %c\n", argv[arg - 1], *argv[arg]);
+               goto out;
             }
         } else {
             fprintf(stderr, "%s: Needs type and value\n", argv[arg - 1]);
-            exit(1);
+         goto out;
         }
-        if (arg < argc)
+      if (arg < argc) {
             values[current_value++] = argv[arg];
-        else {
+      } else {
             fprintf(stderr, "%s: Needs value\n", argv[arg - 2]);
-            exit(1);
+         goto out;
         }
     }
 
-    SOCK_STARTUP;
-
     /*
      * open an SNMP session 
      */
@@ -214,32 +220,30 @@
         /*
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
-        snmp_sess_perror("snmpset", &session);
-        SOCK_CLEANUP;
-        exit(1);
+      snmp_sess_perror_exception("snmpset", &session);
+      goto out;
     }
 
     /*
      * create PDU for SET request and add object names and values to request 
      */
     pdu = snmp_pdu_create(SNMP_MSG_SET);
+   {
+      std::lock_guard<std::mutex> lock(g_netsnmp_mib_mutex);
     for (count = 0; count < current_name; count++) {
         name_length = MAX_OID_LEN;
         if (snmp_parse_oid(names[count], name, &name_length) == NULL) {
-            snmp_perror(names[count]);
+            snmp_perror_exception(names[count]);
             failures++;
-        } else
-            if (snmp_add_var
-                (pdu, name, name_length, types[count], values[count])) {
-            snmp_perror(names[count]);
+         } else if (snmp_add_var(pdu, name, name_length, types[count], values[count])) {
+            snmp_perror_exception(names[count]);
             failures++;
         }
     }
+   }
 
     if (failures) {
-        snmp_close(ss);
-        SOCK_CLEANUP;
-        exit(1);
+      goto close_session;
     }
 
     /*
@@ -249,36 +253,44 @@
     if (status == STAT_SUCCESS) {
         if (response->errstat == SNMP_ERR_NOERROR) {
             if (!quiet) {
-                for (vars = response->variables; vars;
-                     vars = vars->next_variable)
-                    print_variable(vars->name, vars->name_length, vars);
+            for (vars = response->variables; vars; vars = vars->next_variable) {
+               auto const &str_value =
+                   print_variable_to_string(vars->name, vars->name_length, vars);
+               return_vector.push_back(str_value);
+            }
             }
         } else {
-            fprintf(stderr, "Error in packet.\nReason: %s\n",
-                    snmp_errstring(response->errstat));
+         std::string err_msg =
+             "Error in packet.\nReason: " + std::string(snmp_errstring(response->errstat)) + "\n";
+
             if (response->errindex != 0) {
-                fprintf(stderr, "Failed object: ");
-                for (count = 1, vars = response->variables;
-                     vars && (count != response->errindex);
-                     vars = vars->next_variable, count++);
-                if (vars)
-                    fprint_objid(stderr, vars->name, vars->name_length);
-                fprintf(stderr, "\n");
+            err_msg = err_msg + "Failed object: ";
+            for (count = 1, vars = response->variables; vars && count != response->errindex;
+                 vars = vars->next_variable, count++)
+               /*EMPTY*/;
+            if (vars) {
+               err_msg = err_msg + print_objid_to_string(vars->name, vars->name_length);
+            }
+            err_msg = err_msg + "\n";
             }
-            exitval = 2;
+         throw PacketErrorBase(err_msg);
         }
     } else if (status == STAT_TIMEOUT) {
-        fprintf(stderr, "Timeout: No Response from %s\n",
-                session.peername);
-        exitval = 1;
+      std::string err_msg = "Timeout: No Response from " + std::string(session.peername) + ".\n";
+      throw TimeoutErrorBase(err_msg);
     } else {                    /* status == STAT_ERROR */
-        snmp_sess_perror("snmpset", ss);
-        exitval = 1;
+      snmp_sess_perror_exception("snmpset", ss);
     }
 
-    if (response)
+   if (response) {
         snmp_free_pdu(response);
+   }
+
+close_session:
     snmp_close(ss);
+
+out:
+   clear_net_snmp_library_data();
     SOCK_CLEANUP;
-    return exitval;
+   return parse_results(return_vector);
 }
