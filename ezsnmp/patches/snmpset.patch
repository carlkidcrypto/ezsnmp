--- net-snmp-master/apps/snmpset.c 2024-09-06 10:48:16
+++ snmpset.cpp                    2024-10-01 09:26:15
@@ -1,3 +1,4 @@
+/* straight copy from https://github.com/net-snmp/net-snmp/tree/master/apps */
 /*
  * snmpset.c - send snmp SET requests to a network entity.
  *
@@ -64,8 +65,11 @@
 
 #include <net-snmp/net-snmp-includes.h>
 
-void
-usage(void)
+#include <stdexcept>
+#include "snmpwalk.h"
+#include "helpers.h"
+
+void snmpset_usage(void)
 {
     fprintf(stderr, "USAGE: snmpset ");
     snmp_parse_args_usage(stderr);
@@ -83,19 +87,19 @@
     fprintf(stderr,
             "\tU: unsigned int64, I: signed int64, F: float, D: double\n");
 #endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */
-
 }
 
 static int quiet = 0;
 
-static
-    void
-optProc(int argc, char *const *argv, int opt)
+void snmpset_optProc(int argc, char *const *argv, int opt)
 {
-    switch (opt) {
+   switch (opt)
+   {
     case 'C':
-        while (*optarg) {
-            switch (*optarg++) {
+      while (*optarg)
+      {
+         switch (*optarg++)
+         {
             case 'q':
                 quiet = 1;
                 break;
@@ -109,9 +113,11 @@
     }
 }
 
-int
-main(int argc, char *argv[])
+int snmpset(const std::vector<std::string> &args)
 {
+   int argc;
+   std::unique_ptr<char*[]> argv = create_argv(args, argc);
+
     netsnmp_session session, *ss;
     netsnmp_pdu    *pdu, *response = NULL;
     netsnmp_variable_list *vars;
@@ -136,41 +142,48 @@
     /*
      * get the common command line arguments 
      */
-    switch (arg = snmp_parse_args(argc, argv, &session, "C:", optProc)) {
+   switch (arg = snmp_parse_args(argc, argv.get(), &session, "C:", snmpset_optProc))
+   {
     case NETSNMP_PARSE_ARGS_ERROR:
-        goto out;
+      throw std::runtime_error("NETSNMP_PARSE_ARGS_ERROR");
+
     case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exitval = 0;
-        goto out;
+      throw std::runtime_error("NETSNMP_PARSE_ARGS_SUCCESS_EXIT");
+
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
-        usage();
+      snmpset_usage();
         goto out;
     default:
         break;
     }
 
-    if (arg >= argc) {
+   if (arg >= argc)
+   {
         fprintf(stderr, "Missing object name\n");
-        usage();
+      snmpset_usage();
         goto out;
     }
-    if ((argc - arg) > 3*SNMP_MAX_CMDLINE_OIDS) {
+   if ((argc - arg) > 3 * SNMP_MAX_CMDLINE_OIDS)
+   {
         fprintf(stderr, "Too many assignments specified. ");
         fprintf(stderr, "Only %d allowed in one request.\n", SNMP_MAX_CMDLINE_OIDS);
-        usage();
+      snmpset_usage();
         goto out;
     }
 
     /*
      * get object names, types, and values 
      */
-    for (; arg < argc; arg++) {
+   for (; arg < argc; arg++)
+   {
         DEBUGMSGTL(("snmp_parse_args", "handling (#%d): %s %s %s\n",
                     arg, argv[arg], arg+1 < argc ? argv[arg+1] : "",
                     arg+2 < argc ? argv[arg+2] : ""));
         names[current_name++] = argv[arg++];
-        if (arg < argc) {
-            switch (*argv[arg]) {
+      if (arg < argc)
+      {
+         switch (*argv[arg])
+         {
             case '=':
             case 'i':
             case 'u':
@@ -196,13 +209,16 @@
                         *argv[arg]);
                 goto out;
             }
-        } else {
+      }
+      else
+      {
             fprintf(stderr, "%s: Needs type and value\n", argv[arg - 1]);
             goto out;
         }
         if (arg < argc)
             values[current_value++] = argv[arg];
-        else {
+      else
+      {
             fprintf(stderr, "%s: Needs value\n", argv[arg - 2]);
             goto out;
         }
@@ -212,7 +228,8 @@
      * open an SNMP session 
      */
     ss = snmp_open(&session);
-    if (ss == NULL) {
+   if (ss == NULL)
+   {
         /*
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
@@ -224,14 +241,16 @@
      * create PDU for SET request and add object names and values to request 
      */
     pdu = snmp_pdu_create(SNMP_MSG_SET);
-    for (count = 0; count < current_name; count++) {
+   for (count = 0; count < current_name; count++)
+   {
         name_length = MAX_OID_LEN;
-        if (snmp_parse_oid(names[count], name, &name_length) == NULL) {
+      if (snmp_parse_oid(names[count], name, &name_length) == NULL)
+      {
             snmp_perror(names[count]);
             failures++;
-        } else
-            if (snmp_add_var
-                (pdu, name, name_length, types[count], values[count])) {
+      }
+      else if (snmp_add_var(pdu, name, name_length, types[count], values[count]))
+      {
             snmp_perror(names[count]);
             failures++;
         }
@@ -246,32 +265,43 @@
      * do the request 
      */
     status = snmp_synch_response(ss, pdu, &response);
-    if (status == STAT_SUCCESS) {
-        if (response->errstat == SNMP_ERR_NOERROR) {
-            if (!quiet) {
+   if (status == STAT_SUCCESS)
+   {
+      if (response->errstat == SNMP_ERR_NOERROR)
+      {
+         if (!quiet)
+         {
                 for (vars = response->variables; vars;
                      vars = vars->next_variable)
                     print_variable(vars->name, vars->name_length, vars);
             }
-        } else {
+      }
+      else
+      {
             fprintf(stderr, "Error in packet.\nReason: %s\n",
                     snmp_errstring(response->errstat));
-            if (response->errindex != 0) {
+         if (response->errindex != 0)
+         {
                 fprintf(stderr, "Failed object: ");
                 for (count = 1, vars = response->variables;
                      vars && (count != response->errindex);
-                     vars = vars->next_variable, count++);
+                 vars = vars->next_variable, count++)
+               ;
                 if (vars)
                     fprint_objid(stderr, vars->name, vars->name_length);
                 fprintf(stderr, "\n");
             }
             exitval = 2;
         }
-    } else if (status == STAT_TIMEOUT) {
+   }
+   else if (status == STAT_TIMEOUT)
+   {
         fprintf(stderr, "Timeout: No Response from %s\n",
                 session.peername);
         exitval = 1;
-    } else {                    /* status == STAT_ERROR */
+   }
+   else
+   { /* status == STAT_ERROR */
         snmp_sess_perror("snmpset", ss);
         exitval = 1;
     }
