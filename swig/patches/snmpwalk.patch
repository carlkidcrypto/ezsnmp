--- snmpwalk.c   2024-09-13 17:47:48
+++ snmpwalk.cpp 2024-09-13 17:47:48
@@ -1,3 +1,4 @@
+/* straight copy from https://github.com/net-snmp/net-snmp/tree/master/apps */
 /*
  * snmpwalk.c - send snmp GETNEXT requests to a network entity, walking a
  * subtree.
@@ -76,8 +77,11 @@
 
 char           *end_name = NULL;
 
-void
-usage(void)
+#include <stdexcept>
+#include "snmpwalk.h"
+#include "helpers.h"
+
+void snmpwalk_usage(void)
 {
     fprintf(stderr, "USAGE: snmpwalk ");
     snmp_parse_args_usage(stderr);
@@ -97,9 +101,10 @@
     fprintf(stderr, "\t\t\t  E {OID}:  End the walk at the specified OID\n");
 }
 
-void
-snmp_get_and_print(netsnmp_session * ss, oid * theoid, size_t theoid_len)
+std::vector<std::string> snmpwalk_snmp_get_and_print(netsnmp_session *ss, oid *theoid, size_t theoid_len)
 {
+   std::vector<std::string> str_values;
+
     netsnmp_pdu    *pdu, *response;
     netsnmp_variable_list *vars;
     int             status;
@@ -108,24 +113,32 @@
     snmp_add_null_var(pdu, theoid, theoid_len);
 
     status = snmp_synch_response(ss, pdu, &response);
-    if (status == STAT_SUCCESS && response->errstat == SNMP_ERR_NOERROR) {
-        for (vars = response->variables; vars; vars = vars->next_variable) {
+   if (status == STAT_SUCCESS && response->errstat == SNMP_ERR_NOERROR)
+   {
+      for (vars = response->variables; vars; vars = vars->next_variable)
+      {
             numprinted++;
-            print_variable(vars->name, vars->name_length, vars);
+         auto str_value = print_variable_to_string(vars->name, vars->name_length, vars);
+         str_values.push_back(str_value);
         }
     }
-    if (response) {
+   if (response)
+   {
         snmp_free_pdu(response);
     }
+
+   return str_values;
 }
 
-static void
-optProc(int argc, char *const *argv, int opt)
+void snmpwalk_optProc(int argc, char *const *argv, int opt)
 {
-    switch (opt) {
+   switch (opt)
+   {
     case 'C':
-        while (*optarg) {
-            switch (*optarg++) {
+      while (*optarg)
+      {
+         switch (*optarg++)
+         {
             case 'i':
                 netsnmp_ds_toggle_boolean(NETSNMP_DS_APPLICATION_ID,
 					  NETSNMP_DS_WALK_INCLUDE_REQUESTED);
@@ -170,9 +183,9 @@
     }
 }
 
-int
-main(int argc, char *argv[])
+std::vector<std::string> snmpwalk(int argc, char *argv[])
 {
+   std::vector<std::string> return_vector;
     netsnmp_session session, *ss;
     netsnmp_pdu    *pdu, *response;
     netsnmp_variable_list *vars;
@@ -219,15 +232,18 @@
     /*
      * get the common command line arguments 
      */
-    switch (arg = snmp_parse_args(argc, argv, &session, "C:", optProc)) {
+   switch (arg = snmp_parse_args(argc, argv, &session, "C:", snmpwalk_optProc))
+   {
     case NETSNMP_PARSE_ARGS_ERROR:
-        goto out;
-    case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
-        exitval = 0;
-        goto out;
+      throw std::runtime_error("NETSNMP_PARSE_ARGS_ERROR");
+
+   case NETSNMP_PARSE_ARGS_SUCCESS_EXIT:
+      throw std::runtime_error("NETSNMP_PARSE_ARGS_SUCCESS_EXIT");
+
     case NETSNMP_PARSE_ARGS_ERROR_USAGE:
-        usage();
-        goto out;
+      snmpwalk_usage();
+      return return_vector;
+
     default:
         break;
     }
@@ -235,16 +251,20 @@
     /*
      * get the initial object and subtree 
      */
-    if (arg < argc) {
+   if (arg < argc)
+   {
         /*
          * specified on the command line 
          */
         rootlen = MAX_OID_LEN;
-        if (snmp_parse_oid(argv[arg], root, &rootlen) == NULL) {
+      if (snmp_parse_oid(argv[arg], root, &rootlen) == NULL)
+      {
             snmp_perror(argv[arg]);
-            goto out;
+         return return_vector;
         }
-    } else {
+   }
+   else
+   {
         /*
          * use default value 
          */
@@ -257,13 +277,17 @@
      *  then convert this to an OID, otherwise
      *  move to the next sibling of the start.
      */
-    if ( end_name ) {
+   if (end_name)
+   {
         end_len = MAX_OID_LEN;
-        if (snmp_parse_oid(end_name, end_oid, &end_len) == NULL) {
+      if (snmp_parse_oid(end_name, end_oid, &end_len) == NULL)
+      {
             snmp_perror(end_name);
-            goto out;
+         return return_vector;
         }
-    } else {
+   }
+   else
+   {
         memmove(end_oid, root, rootlen*sizeof(oid));
         end_len = rootlen;
         end_oid[end_len-1]++;
@@ -273,12 +297,13 @@
      * open an SNMP session 
      */
     ss = snmp_open(&session);
-    if (ss == NULL) {
+   if (ss == NULL)
+   {
         /*
          * diagnose snmp_open errors with the input netsnmp_session pointer 
          */
         snmp_sess_perror("snmpwalk", &session);
-        goto out;
+      return return_vector;
     }
 
     /*
@@ -292,15 +317,22 @@
     check =
         !netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
                         NETSNMP_DS_WALK_DONT_CHECK_LEXICOGRAPHIC);
-    if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_WALK_INCLUDE_REQUESTED)) {
-        snmp_get_and_print(ss, root, rootlen);
+   if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_WALK_INCLUDE_REQUESTED))
+   {
+      auto retval = snmpwalk_snmp_get_and_print(ss, root, rootlen);
+
+      for (const auto& item : retval)
+      {
+         return_vector.push_back(item);
     }
+   }
 
     if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
                                NETSNMP_DS_WALK_TIME_RESULTS))
         netsnmp_get_monotonic_clock(&tv1);
     exitval = 0;
-    while (running) {
+   while (running)
+   {
         /*
          * create PDU for GETNEXT request and add object name to request 
          */
@@ -313,17 +345,21 @@
         if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_WALK_TIME_RESULTS_SINGLE))
             netsnmp_get_monotonic_clock(&tv_a);
         status = snmp_synch_response(ss, pdu, &response);
-        if (status == STAT_SUCCESS) {
+      if (status == STAT_SUCCESS)
+      {
             if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_WALK_TIME_RESULTS_SINGLE))
                 netsnmp_get_monotonic_clock(&tv_b);
-            if (response->errstat == SNMP_ERR_NOERROR) {
+         if (response->errstat == SNMP_ERR_NOERROR)
+         {
                 /*
                  * check resulting variables 
                  */
                 for (vars = response->variables; vars;
-                     vars = vars->next_variable) {
+                 vars = vars->next_variable)
+            {
                     if (snmp_oid_compare(end_oid, end_len,
-                                         vars->name, vars->name_length) <= 0) {
+                                    vars->name, vars->name_length) <= 0)
+               {
                         /*
                          * not part of this subtree 
                          */
@@ -335,17 +371,21 @@
                         fprintf(stdout, "%f s: ",  
                                 (double) (tv_b.tv_usec - tv_a.tv_usec)/1000000 +
                                 (double) (tv_b.tv_sec - tv_a.tv_sec));
-                    print_variable(vars->name, vars->name_length, vars);
+
+               auto str_value = print_variable_to_string(vars->name, vars->name_length, vars);
+               return_vector.push_back(str_value);
+
                     if ((vars->type != SNMP_ENDOFMIBVIEW) &&
                         (vars->type != SNMP_NOSUCHOBJECT) &&
-                        (vars->type != SNMP_NOSUCHINSTANCE)) {
+                   (vars->type != SNMP_NOSUCHINSTANCE))
+               {
                         /*
                          * not an exception value 
                          */
-                        if (check
-                            && snmp_oid_compare(name, name_length,
+                  if (check && snmp_oid_compare(name, name_length,
                                                 vars->name,
-                                                vars->name_length) >= 0) {
+                                                vars->name_length) >= 0)
+                  {
                             fflush(stdout);
                             fprintf(stderr, "Error: OID not increasing: ");
                             fprint_objid(stderr, name, name_length);
@@ -359,23 +399,30 @@
                         memmove((char *) name, (char *) vars->name,
                                 vars->name_length * sizeof(oid));
                         name_length = vars->name_length;
-                    } else
+               }
+               else
                         /*
                          * an exception value, so stop 
                          */
                         running = 0;
                 }
-            } else {
+         }
+         else
+         {
                 /*
                  * error in response, print it 
                  */
                 running = 0;
-                if (response->errstat == SNMP_ERR_NOSUCHNAME) {
+            if (response->errstat == SNMP_ERR_NOSUCHNAME)
+            {
                     printf("End of MIB\n");
-                } else {
+            }
+            else
+            {
                     fprintf(stderr, "Error in packet.\nReason: %s\n",
                             snmp_errstring(response->errstat));
-                    if (response->errindex != 0) {
+               if (response->errindex != 0)
+               {
                         fprintf(stderr, "Failed object: ");
                         for (count = 1, vars = response->variables;
                              vars && count != response->errindex;
@@ -389,12 +436,16 @@
                     exitval = 2;
                 }
             }
-        } else if (status == STAT_TIMEOUT) {
+      }
+      else if (status == STAT_TIMEOUT)
+      {
             fprintf(stderr, "Timeout: No Response from %s\n",
                     session.peername);
             running = 0;
             exitval = 1;
-        } else {                /* status == STAT_ERROR */
+      }
+      else
+      { /* status == STAT_ERROR */
             snmp_sess_perror("snmpwalk", ss);
             running = 0;
             exitval = 1;
@@ -406,24 +457,33 @@
                                NETSNMP_DS_WALK_TIME_RESULTS))
         netsnmp_get_monotonic_clock(&tv2);
 
-    if (numprinted == 0 && status == STAT_SUCCESS) {
+   if (numprinted == 0 && status == STAT_SUCCESS)
+   {
         /*
          * no printed successful results, which may mean we were
          * pointed at an only existing instance.  Attempt a GET, just
          * for get measure. 
          */
-        if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_WALK_DONT_GET_REQUESTED)) {
-            snmp_get_and_print(ss, root, rootlen);
+      if (!netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_WALK_DONT_GET_REQUESTED))
+      {
+         auto retval = snmpwalk_snmp_get_and_print(ss, root, rootlen);
+
+         for (const auto &item : retval)
+         {
+            return_vector.push_back(item);
         }
     }
+   }
     snmp_close(ss);
 
     if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
-                               NETSNMP_DS_WALK_PRINT_STATISTICS)) {
+                              NETSNMP_DS_WALK_PRINT_STATISTICS))
+   {
         printf("Variables found: %d\n", numprinted);
     }
     if (netsnmp_ds_get_boolean(NETSNMP_DS_APPLICATION_ID,
-                               NETSNMP_DS_WALK_TIME_RESULTS)) {
+                              NETSNMP_DS_WALK_TIME_RESULTS))
+   {
         fprintf (stderr, "Total traversal time = %f seconds\n",
                  (double) (tv2.tv_usec - tv1.tv_usec)/1000000 +
                  (double) (tv2.tv_sec - tv1.tv_sec));
@@ -432,5 +492,5 @@
 out:
     netsnmp_cleanup_session(&session);
     SOCK_CLEANUP;
-    return exitval;
+   return return_vector;
 }
